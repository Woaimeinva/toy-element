





**Toy-Element开发文档**

# 1.项目搭建

## 1.创建根目录并初始化项目

创建根目录，并将根目录命名为toy-element，并在根目录下初始化项目

```bash
pnpm init
```

在根目录下创建子目录packages

创建pnpm-workspace.yaml，告诉pnpm需要管理的包，这里我们只管理packages这个子包

```yaml
packages:
	- "packages/*"
```

当前文件树

```
toy-element
|-- packages
--- package.json
--- pnpm-workspace.yaml
```

## 2.在packages目录下创建子包并初始化

通过一个shell脚本完成这个重复的过程,这个脚本的大致流程就是遍历创建子目录并对子目录完成初始化

```bash
for i in components core docs hooks theme utils; do
mkdir $i
cd $i
pnpm init
cd ..
done
```

在packages目录下，创建一个vue-ts项目

```shell
pnpm create vite play --template vue-ts
```

创建完后，文件的结构就是这样的

```
toy-element
|-- packages
	|--- components
    	 --- package.json
    |--- core
    	 --- package.json
    |--- docs
    	 --- package.json
    |--- hooks
    	 --- package.json
    |--- play
    	 --- package.json
    	 ...
    |--- theme
    	 --- package.json
    |--- utils
    	 --- package.json
--- package.json
--- pnpm-workspace.yaml
```

重新为各个子包命名，除了core目录下的package.json文件的name为toy-element,其他package.json的name属性前都加上@toy-element/，这样的处理是为了防止跟其他npm上的包重名

示例：

```json
{
  "name": "@toy-element/components",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "packageManager": "pnpm@10.12.4"
}
```

## 3.安装依赖

**1.安装基础依赖**

```shell
pnpm add -Dw typescript@^5.2.2 vite@^5.1.4 vitest@^1.4.0 vue-tsc@^1.8.27 postcss-color-mix@^1.1.0 postcss-each@^1.1.0 postcss-each-variables@^0.3.0 postcss-for@^2.1.1 postcss-nested@^6.0.1 @types/node@^20.11.20 @types/lodash-es@^4.17.12 @vitejs/plugin-vue@^5.0.4 @vitejs/plugin-vue-jsx@^3.1.0 @vue/tsconfig@^0.5.1

pnpm add -w lodash-es@^4.17.21 vue@^3.4.19
```

**建立本地包的链接**

在根目录下的package.json中添加如下内容，建立本地包的链接，说明以下几个依赖是从本地包安装的

```json
{
  "dependencies": {
    "toy-element": "workspace:*",
    "@toy-element/hooks": "workspace:*",
    "@toy-element/utils": "workspace:*",
    "@toy-element/theme": "workspace:*"
  }
}
```

**2.为components包添加依赖**

```shell
pnpm add -D @vue/test-utils@^2.4.5 @vitest/coverage-v8@^1.4.0 jsdom@^24.0.0 --filter @toy-element/components
pnpm add @popperjs/core@^2.11.8 async-validator@^4.2.5 --filter @toy-element/components
```

**3.为core包建立链接**

```json
{
  "dependencies": {
    "@toy-element/components": "workspace:*"
  }
}
```

**4.为docs添加依赖**

```shell
pnpm add -D vitepress@1.0.0-rc.44 --filter @toy-element/docs
```

**5.删除冗余依赖**

与根目录下的package.json文件比较删除play目录下的package.json文件中依赖与开发依赖的重复部分

删除完依赖的样子

```json
{
  "name": "@toy-element/play",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc -b && vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.1"
  }
}
```

**6.统一配置tsconifg**

首先删除play目录下的tsconfig配置，因为我们会在根目录下统一配置

**tsconfig.json**

```json
{
    "extends": "@vue/tsconfig/tsconfig.dom.json",
    "compilerOptions": {
      "target": "ES2020",
      "useDefineForClassFields": true,
      "module": "ESNext",
      "lib": ["ES2020", "DOM", "DOM.Iterable"],
      "skipLibCheck": true,
  
      /* Bundler mode */
      "moduleResolution": "bundler",
      "allowImportingTsExtensions": true,
      "resolveJsonModule": true,
      "isolatedModules": true,
      "noEmit": true,
      "jsx": "preserve",
      "jsxImportSource": "vue",
  
      /* Linting */
      "strict": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noFallthroughCasesInSwitch": true
    },
    "include": ["packages/**/*.ts", "packages/**/*.tsx", "packages/**/*.vue"]
  }
```

**tsconfig.node.json**

```json
{
    "extends": "@tsconfig/node18/tsconfig.json",
    "include": ["packages/**/**.config.ts"],
    "compilerOptions": {
      "composite": true,
      "module": "ESNext",
      "moduleResolution": "Bundler",
      "types": ["node"]
    }
  }
```

**postcss.cjs**

这里我们额外配置一下postcss

```cjs
/* eslint-env node */
module.exports = {
    plugins: [
      require("postcss-nested"),
      require("postcss-each-variables"),
      require("postcss-each")({
        plugins: {
          beforeEach: [require("postcss-for"), require("postcss-color-mix")],
        },
      }),
    ],
  };
```

**7.安装依赖**

在根目录下运行 pnpm install，为所有包安装依赖

```shell
pnpm install
```

## 4.建立core包和components包的连接

**前言：**这个组件库我们的出口为core包，这也就是为什么core包的package.json文件中的name为"toy-element"的原因

### 1.创建Button组件

在components包下创建一个目录命名为Button，Button目录下存放组件Button和Button目录的入口文件index.ts

**Button.vue**

创建一个组件，并定义名称

```vue
<script setup lang="ts">
// 定义组件名称
defineOptions({
    name: 'ErButton'
})
</script>
<template>
    <button style="background-color: blue;">click me</button>
</template>
```

**index.ts**

```typescript
import Button from "./Button.vue";
import { withInstall } from '@toy-element/utils'
export const ErButton = withInstall(Button)
```

这里就是注册一个插件，并将其暴露出去

看到这里你会自然疑惑地问withInstall这个方法是做什么的，接下来我们就详细讲讲这一个方法

### 2.编写install.ts

在utils包下创建install.ts文件，用于组件的注册

```typescript
import type { App, Plugin } from "vue";
import { each } from "lodash-es";

type SFCWithInstall<T> = T & Plugin;

export function makeInstaller(components: Plugin[]) {
  const install = (app: App) =>
    each(components, (c) => {
      app.use(c);
    });

  return install;
}

export const withInstall = <T>(component: T) => {
  (component as SFCWithInstall<T>).install = (app: App) => {
    const name = (component as any)?.name || "UnnamedComponent";
    app.component(name, component as SFCWithInstall<T>);
  };
  return component as SFCWithInstall<T>;
};
```

**先讲讲withInstall方法**

```typescript
export const withInstall = <T>(component: T) => {
  (component as SFCWithInstall<T>).install = (app: App) => {
    const name = (component as any)?.name || "UnnamedComponent";
    app.component(name, component as SFCWithInstall<T>);
  };
  return component as SFCWithInstall<T>;
};
```

因为这个组件库需要支持全局导入，所以就涉及到了Vue3的一个插件的概念，如果需要全局使用Vue3的一个插件，那么我们需要使用app.use()方法，如果要使用这个方法的话，那么我们必须要为插件设置一个install属性。

所以这里的这个方法为传入的component添加了install属性，并将component注册为全局组件，同时它的返回值还是component所以它还是可以作为一个组件在模板中被使用

**这里我们再讲makeInstaller方法**

```typescript
export function makeInstaller(components: Plugin[]) {
  const install = (app: App) =>
    each(components, (c) => {
      app.use(c);
    });

  return install;
}
```

这个方法的参数是我们注册好的插件(这里也就是我们注册好的组件，也就是通过withInstall方法注册的组件)，它的返回值是一个函数，我们可以看出这个函数是在为所有component调用app.use方法，注意我们这里并没有调用这个方法，我们只是用它来定义了一个函数体，他会在我们安装这个组件库的时候才调用，也就是我们在另一个vue项目中，为那个项目安装插件的时候，也就是app.use(组件库)的时候，才回去调用里面安装插件逻辑

### 3.暴露出所有组件

我们在components目录下的index.ts文件中将所有组件暴露出去

```typescript
export * from './Button/index'
export * from './Box/index'
```

### 4.在组件库的入口文件中暴露所有组件

在core目录下创建两个文件一个是components.ts另一个是index.ts

**components.ts**

在这个文件中引入components包下的所有组件，并以插件数组的形式暴露出去

```typescript
// components.ts

import { ErButton, ErBox } from "@toy-element/components";
import type { Plugin } from "vue";

export default [ErButton, ErBox] as Plugin[];
```

**index.ts**

在这个文件中默认导出一个全局安装插件(组件)的方法，并且又导出了所有组件，这样我们的组件库就支持按需导入和全局导入了

```typescript
import { makeInstaller } from "@toy-element/utils";
import components from "./components";

const installer = makeInstaller(components);

export * from "@toy-element/components";
export default installer;
```

**按需导入**

在play演示包中，我们这样引入就是按需引入了

```vue
<script setup lang="ts">
import { ErBox } from 'toy-element';
</script>

<template>
  <er-box></er-box>
</template>

```

**全局导入**

首先我们在play演示包的main.ts文件中使用我们的组件库，在调用use方法的时候它就会调用我们的安装函数为我们全局注册所有组件

```typescript
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import ToyElement from 'toy-element'
createApp(App).use(ToyElement).mount('#app')
```

这样我们就可以在全局直接使用了

```vue
<template>
  <er-button></er-button>
</template>
```

## 5.设置样式

在theme包下创建reset.css和index.css文件

**reset.css**

```css
/** reset.css */
body {
  font-family: var(--er-font-family);
  font-weight: 400;
  font-size: var(--er-font-size-base);
  line-height: calc(var(--er-font-size-base) * 1.2);
  color: var(--er-text-color-primary);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-tap-highlight-color: transparent;
}

a {
  color: var(--er-color-primary);
  text-decoration: none;

  &:hover,
  &:focus {
    color: var(--er-color-primary-light-3);
  }

  &:active {
    color: var(--er-color-primary-dark-2);
  }
}

h1,
h2,
h3,
h4,
h5,
h6 {
  color: var(--er-text-color-regular);
  font-weight: inherit;

  &:first-child {
    margin-top: 0;
  }

  &:last-child {
    margin-bottom: 0;
  }
}

h1 {
  font-size: calc(var(--er-font-size-base) + 6px);
}

h2 {
  font-size: calc(var(--er-font-size-base) + 4px);
}

h3 {
  font-size: calc(var(--er-font-size-base) + 2px);
}

h4,
h5,
h6,
p {
  font-size: inherit;
}

p {
  line-height: 1.8;

  &:first-child {
    margin-top: 0;
  }

  &:last-child {
    margin-bottom: 0;
  }
}

sup,
sub {
  font-size: calc(var(--er-font-size-base) - 1px);
}

small {
  font-size: calc(var(--er-font-size-base) - 2px);
}

hr {
  margin-top: 20px;
  margin-bottom: 20px;
  border: 0;
  border-top: 1px solid var(--er-border-color-lighter);
}
```

**index.css**

在这个文件中引入我们清除默认样式的文件

```css
@import './reset.css'
```

**修改package.json文件**

我们需要将theme包的入口文件更改为index.css，这样当我们引入这个包时，引入的就是入口文件了

**在core包中引入theme包**

在core包中的index.ts中引入theme包，为什么不能在components包中引入呢？在components包中引入也是可以的，但不推荐

我替你问了AI，AI是这样回答的

原因简述：统一入口与可选性：core 作为对外入口，集中引入 @toy-element/theme，用户 app.use(ToyElement) 时自动获得样式；而按需引入组件时，用户可自行选择是否/如何引入样式，避免被动强绑。避免重复注入与体积膨胀：样式放在 components 会导致多处重复引入（多个组件各自引样式），难以去重，打包体积增大。更好 Tree-shaking 与无副作用：components 包保持“纯组件、无副作用”，便于摇树优化与 SSR；样式这种副作用性交由 core 统一处理。主题解耦与可替换：core 负责“组装”，样式在主题包中可替换（定制皮肤/按需构建），不污染组件实现层。责任清晰：components 只关心组件实现，theme 只关心样式，core 负责组合与对外暴露，架构更清晰。

```typescript
import { makeInstaller } from "@toy-element/utils";
import components from "./components";
import '@toy-element/theme/index.css'
const installer = makeInstaller(components);

export * from "@toy-element/components";
export default installer;
```

# 2.创建VitePress文档

进入docs目录，运行命令npx vitepress init创建VitePress，也就是组件库的使用文档

```shell
npx vitepress init
```

这是vitepress的相关命令

```json
{
  "name": "@toy-element/docs",
  "version": "1.0.0",
  "description": "",
  "main": "index.ts",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "docs:dev": "vitepress dev",
    "docs:build": "vitepress build",
    "docs:preview": "vitepress preview"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "packageManager": "pnpm@10.12.4",
  "devDependencies": {
    "vitepress": "1.0.0-rc.44"
  }
}
```

在根目录下的package.json文件中添加vitepress的相关命令

```json
{
   "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "dev": "pnpm --filter @toy-element/play dev ",
        "docs:dev": "pnpm --filter @toy-element/docs docs:dev",
        "docs:build": "pnpm --filter @toy-element/docs build",
  },
}
```

# 3.创建StoryBook

**介绍：StoryBook是一个用于独立构建、测试和展示UI组件的开源工具，可以把它想象成UI组件的实验室**

**使用：**

1、进入Vue项目的根目录，运行以下命令

```shell
pnpm create storybook@latest
```

选择Vue3选项

# 4.组件开发

## 1.ErIcon

**依赖：**

​	这里我们需要引入FontAwesome图标库，作为我们的图标库

​	将这三个依赖添加到生成依赖中，再执行pnpm install安装依赖

```json
{
    "dependencies": {
		"@fortawesome/fontawesome-svg-core": "^6.5.2",
    	"@fortawesome/free-solid-svg-icons": "^6.5.2",
    	"@fortawesome/vue-fontawesome": "^3.0.8"
    }
}
```

npm install @fortawesome/vue-fontawesome@latest-3

​	这个依赖是支持vue3的组件

npm install @fortawesome/fontawesome-svg-core

​	这个依赖是这个图标库的核心包

npm install @fortawesome/free-solid-svg-icons

​	这个依赖是实心图标的依赖

**引入：**

​	1、在我们的ErIcon.vue文件中，引入font-awesome-icon组件

```vue
<script>
    import { FontAwesomeIcon } from "@fortawesome/vue-fontawesome";
</script>
```

​	2、在core包的index.ts文件中，引入我们的图标库，并将图标库添加到library中去

```ts
import { library } from "@fortawesome/fontawesome-svg-core";
import { fas } from "@fortawesome/free-solid-svg-icons"
library.add(fas);
```

**开发：**

**Icon.vue**

```vue
<script setup lang="ts">
// 引入组件的props类型定义
import { type IconProps } from "./type";
// 引入FontAwesomeIcon组件
import { FontAwesomeIcon } from "@fortawesome/vue-fontawesome";
// 引入omit方法，该方法能够去除对象中的指定属性，并返回一个新的对象
import { omit } from "lodash-es";
import { computed } from "vue";

// 定义组件名称，并设置inheritAttrs为false，避免将属性绑定到组件根元素上
defineOptions({
  name: "ErIcon",
  inheritAttrs: false,
});

// 定义组件的props
const props = defineProps<IconProps>();

// 通过loadsh的omit方法排除type和color属性，返回一个新的对象
const filterProps = computed(() => omit(props, ["type", "color"]));

const customStyles = computed(() => ({ color: props.color ?? void 0 }));
</script>

<template>
  <i
    class="er-icon"
    :class="{ [`er-icon--${type}`]: type }"
    :style="customStyles"
    v-bind="$attrs"
  >
    <font-awesome-icon v-bind="filterProps" />
  </i>
</template>

<style scoped>
/* 引入样式 */
@import "./style.css";
</style>
```

**style.css**

```css
.er-icon {
  --er-icon-color: inherit;
  display: inline-flex;
  justify-content: center;
  align-items: center;
  position: relative;
  fill: currentColor;
  color: var(--er-icon-color);
  font-size: inherit;
}

@each $val in primary, info, success, warning, danger {
  .er-icon--$(val) {
    --er-icon-color: var(--er-color-$(val));
  }
}
```

**type.ts**

```typescript
import type { IconDefinition } from "@fortawesome/fontawesome-svg-core";

export interface IconProps {
  border?: boolean;
  fixedWidth?: boolean;
  flip?: "horizontal" | "vertical" | "both";
  icon: object | Array<string> | string | IconDefinition;
  mask?: object | Array<string> | string;
  listItem?: boolean;
  pull?: "right" | "left";
  pulse?: boolean;
  rotation?: 90 | 180 | 270 | "90" | "180" | "270";
  swapOpacity?: boolean;
  size?:
    | "2xs"
    | "xs"
    | "sm"
    | "lg"
    | "xl"
    | "2xl"
    | "1x"
    | "2x"
    | "3x"
    | "4x"
    | "5x"
    | "6x"
    | "7x"
    | "8x"
    | "9x"
    | "10x";
  spin?: boolean;
  transform?: object | string;
  symbol?: boolean | string;
  title?: string;
  inverse?: boolean;
  bounce?: boolean;
  shake?: boolean;
  beat?: boolean;
  fade?: boolean;
  beatFade?: boolean;
  spinPulse?: boolean;
  spinReverse?: boolean;
  type?: "primary" | "success" | "warning" | "danger" | "info";
  color?: string;
}
```

**index.ts**

```typescript
import { withInstall } from "@toy-element/utils";
import Icon from "./Icon.vue";
// 注册组件，并暴露
export const ErIcon = withInstall(Icon);
// 将类型定义也暴露出去
export * from "./type";
```

**同样的，我们需要在core包引入这个组件**

## 2.ErButton and ErButtonGroup

# 2.npm发布

## 1.创建npm账号

前往npm官网，创建一个npm账号

## 2.在终端登录npm账号

1.进入终端输入指令 npm login，输入对应的信息即可登录

2.输入指令 npm whoami，来查看是否登录成功

## 3.发布package

1.在终端输入指令 npm publish即可，注意每次发布，版本号都要增加
